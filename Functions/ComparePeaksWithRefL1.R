##############################################
#
# General description:
#
#   The following function reads in genomic a bam file with peaks and a table
#   with L1 ranges on a reference genome.

# Input:
#
#     L1Ranges: path to Rdata file with L1 ranges (generated by script 
#        'GetL1RefRanges_hg19.R')
#     BamFilter: path to bam file that contains reads mapped to L1HS
#     MinMaxCover: minimum maximum coverage to be called a peak 
#     MinGap: minimum gap allowed between two separate peaks. Peaks with 
#        smaller gap than this will be collapsed into one
#     MinDist2L1: minimum distance to reference L1 to be considered 
#        "non-reference" 
#     PacBioWindow <- 1000

# Output:
#   
#    : ...

# Comments:
#   
#    Requires packages csaw

##############################################

ComparePeaksWithRefL1 <- function(
   BamFile,
   OutBamFileFullLengthL1,
   L1Ranges = "/home/hzudohna/L1polymORF/Data/L1RefRanges_hg19.Rdata",
   MinMaxCover = 5,    # minimum maximum coverage to be called a peak 
   MinGap      = 10,
   MinDist2L1  = 3*10^4, # minimum distance to L1 to be called a peak 
   OutFile = "/home/hzudohna/L1polymORF/Data/AnalyzedPacBioL1Ranges.RData"
   ){
  
  cat("*******************************************************\n")
  cat("**                                                   **\n")
  cat("**    Running function ComparePeaksWithRefL1 ...     **\n")
  cat("**                                                   **\n")
  cat("*******************************************************\n\n")
  
   #######################################
   #                                     #
   #    Read in data and                 #
   #   determine coverage                #
   #                                     #
   #######################################

   # Load range objects and make sure all are there
   load(file = L1Ranges)
   blnObjectsLoaded <- sapply(c("L1GRanges", "L1HSFullLength_GRanges", "ChromLengths"),
      function(x) exists(x, where = -1))
   if (any(!blnObjectsLoaded)) {
     stop("Object(s) \n", 
          paste(names(blnObjectsLoaded)[!blnObjectsLoaded], collapse = ", "), 
                                " missing!")
   }

   #######                       
   # Get L1 ranges                    
   #######                                     

   cat("*** Turning reads in", BamFile,"into GRanges ***\n")
browser()
   # Get reads per chromosome
   CoverList <- lapply(1:length(ChromLengths), function(i){
      Chrom       <- names(ChromLengths)[i]
      ChromLength <- ChromLengths[i]
      R1 <- GRanges(seqnames = Chrom, ranges = IRanges(start = 1, end = ChromLength))
      cat("Extracting reads of chromosome", Chrom, "\n")
      Reads <- extractReads(bam.file = BamFile, region = R1)
      ReadCov <- coverage(Reads)
   })

   #######################################
   #                                     #
   #    Determine 'islands' with         #
   #        nonzero coverage             #
   #                                     #
   #######################################

   # Determine separate islands with continuous read coverage and turn islands 
   # into genomic ranges
   IslandList <- lapply(CoverList, function(x){
     Islands <- slice(x, lower = 1)
   })
   Chroms <- names(ChromLengths)
   IslandGRanges <- lapply(1:length(IslandList), function(i){
   GRanges(seqnames = Chroms[i], 
          ranges = IslandList[[i]]@listData[[1]]@ranges,
          coverTotal = viewSums(IslandList[[i]])[[1]],
          coverMax   = viewMaxs(IslandList[[i]])[[1]],
          coverMaxPos   = viewWhichMaxs(IslandList[[i]])[[1]])
   })
   IslandGRanges <- GRangesList(IslandGRanges)
   IslandGRanges <- unlist(IslandGRanges)
   cat(length(IslandGRanges), "distinct peaks\n\n")

   # Merge ranges that are less than MinGap bp apart
   IslGRanges_reduced <- reduce(IslandGRanges, min.gapwidth = MinGap,
                             with.revmap = T)
   cat(length(IslGRanges_reduced), "distinct peaks after merging peaks that")
   cat("are less than", MinGap, "apart\n\n")

   #######################################
   #                                     #
   #    Find 'islands' not overlapping   #
   #        with reference L1            #
   #                                     #
   #######################################
   
   cat("***** Finding 'islands' not overlapping with reference L1 ... *****\n")

   # Find overlaps between islands and L1HS ranges
   blnOverlapIslands_All <- overlapsAny(IslGRanges_reduced, L1GRanges)

   # Get maximum cover and position of maximum cover in reduced ranges
   maxCoverOriginal    <- IslandGRanges@elementMetadata@listData$coverMax
   maxCoverPosOriginal <- IslandGRanges@elementMetadata@listData$coverMaxPos
   maxCover <- sapply(IslGRanges_reduced@elementMetadata@listData$revmap, 
                   function(x) max(maxCoverOriginal[x]))
   maxCoverPos <- sapply(IslGRanges_reduced@elementMetadata@listData$revmap, 
                      function(x) maxCoverPosOriginal[x[which.max(maxCoverOriginal[x])]])
   
   # Get all ranges that make the maximum cover cut-off and don't overlap with
   # reference L1
   idxSuspectL1Ranges <- which(maxCover > MinMaxCover & (!blnOverlapIslands_All))
   SuspectL1Ranges    <- IslGRanges_reduced[idxSuspectL1Ranges]
   cat(length(idxSuspectL1Ranges), "peaks have maximum coverage of at least",
      MinMaxCover, "and do not overlap with reference L1\n")

   # Remove ranges of suspected L1s that are too close to reference L1
   DistToNearestL1    <- nearest(SuspectL1Ranges, L1GRanges)
   idxSuspectL1Ranges <- idxSuspectL1Ranges[DistToNearestL1 >= MinDist2L1]
   SuspectL1Ranges    <- IslGRanges_reduced[idxSuspectL1Ranges]
   maxCoverPos_SuspL1Ranges <- maxCoverPos[idxSuspectL1Ranges]
   cat(length(idxSuspectL1Ranges), "of the above peaks are at least", 
       MinDist2L1, "bp from nearest reference L1\n\n")
   
   #######################################
   #                                     #
   #    Find 'islands' overlapping       #
   #    with full-length reference L1    #
   #                                     #
   #######################################
   
   cat("***** Filtering reads overlapping with full-length reference L1 ... *****\n")

   # Find overlaps between islands and full-length L1HS ranges
   blnOverlapIslands_L1HS <- overlapsAny(IslGRanges_reduced, 
                                         L1HSFullLength_GRanges)
   
   # Get genomoc ranges of islands overlapping with full-length L1HS
   idxFullRefL1Ranges <- which(blnOverlapIslands_L1HS)
   FullRefL1Ranges    <- IslGRanges_reduced[blnOverlapIslands_L1HS]
   
   # Filter bam file to get reads in islands overlapping with full-length L1
   param <- ScanBamParam(which = FullRefL1Ranges, what = scanBamWhat())
   filterBam(file = BamFile, destination = OutBamFileFullLengthL1, param = param)
   
   #######################################################
   #                                                     #
   #    Save results                                     #
   #                                                     #
   #######################################################

   # Save results
   cat("*******  Saving results for ComparePeaksWithRefL1...   *******\n")
   save(list = c("IslGRanges_reduced", "maxCover", "maxCoverPos", 
              "idxSuspectL1Ranges", "SuspectL1Ranges", 
              "FullRefL1Ranges", "idxFullRefL1Ranges"), 
     file = OutFile)

}


