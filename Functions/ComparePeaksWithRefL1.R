##############################################
#
# General description:
#
#   The following function reads in genomic a bam file with peaks and a table
#   with L1 ranges on a reference genome.

# Input:
#
#     L1Ranges: path to Rdata file with L1 ranges (generated by script 
#        'GetL1RefRanges_hg19.R')
#     BamFilter: path to bam file that contains reads mapped to L1HS
#     MinMaxCover: minimum maximum coverage to be called a peak 
#     MinGap: minimum gap allowed between two separate peaks. Peaks with 
#        smaller gap than this will be collapsed into one
#     MinDist2L1: minimum distance to reference L1 to be considered 
#        "non-reference" 
#     PacBioWindow <- 1000

# Output:
#   
#    : ...

# Comments:
#   
#    Requires packages csaw

##############################################

ComparePeaksWithRefL1 <- function(
   BamFile,
   OutBamFileFullLengthL1,
   L1Ranges = "/home/hzudohna/L1polymORF/Data/L1RefRanges_hg19.Rdata",
   MinMaxCover = 5,    # minimum maximum coverage to be called a peak 
   MinGap      = 10,
   NrChromPieces = 20,
   MinDist2L1  = 3*10^4, # minimum distance to L1 to be called a peak 
   OutFile = "/home/hzudohna/L1polymORF/Data/AnalyzedPacBioL1Ranges.RData",
   EndList = NULL
   ){
  
  cat("*******************************************************\n")
  cat("**                                                   **\n")
  cat("**    Running function ComparePeaksWithRefL1 ...     **\n")
  cat("**                                                   **\n")
  cat("*******************************************************\n\n")
  
   #######################################
   #                                     #
   #    Read in data and                 #
   #   determine coverage                #
   #                                     #
   #######################################

   # Load range objects and make sure all are there
   load(file = L1Ranges)
   blnObjectsLoaded <- sapply(c("L1GRanges", "L1HSFullLength_GRanges", "ChromLengths"),
      function(x) exists(x, where = -1))
   if (any(!blnObjectsLoaded)) {
     stop("Object(s) \n", 
          paste(names(blnObjectsLoaded)[!blnObjectsLoaded], collapse = ", "), 
                                " missing!")
   }

   #######################################
   #                                     #
   #    Determine 'islands' with         #
   #        nonzero coverage             #
   #                                     #
   #######################################
   
   cat("*** Turning reads in", BamFile,"into GRanges ***\n")
   # Determine separate islands with continuous read coverage and turn islands 
   # into genomic ranges
   #browser()
   if (is.null(EndList)){
     EndList <- lapply(c(1:length(ChromLengths)), function(i){
       Chrom       <- names(ChromLengths)[i]
       ChromLength <- ChromLengths[i]
       Ends <- seq(1, ChromLength, floor(ChromLength/ NrChromPieces))
       if (Ends[length(Ends)] < ChromLength) Ends <- c(Ends, ChromLength)
       Ends
     }) 
   }
   GRangesNonRef <- lapply(c(1:length(ChromLengths)), function(i){
      Chrom       <- names(ChromLengths)[i]
      ChromLength <- ChromLengths[i]
      Ends <- EndList[[i]]
      StepW <- median(Ends[-1] - Ends[-length(Ends)])
      cat("****   Extracting reads of chromosome", Chrom, "*****\n")
      GRList <- lapply (1:(length(Ends) - 1), function (j) {
        cat("Pocessing from", Chrom, "piece", j, "of", length(Ends), "\n")
        
        # Create a genomic reange
        R1 <- GRanges(seqnames = Chrom, ranges = IRanges(start = Ends[j], 
                                                         end = Ends[j] + StepW))
        # Extract reads overlapping with range and determine coverage
        Reads <- extractReads(bam.file = BamFile, region = R1)
        ReadCov <- coverage(Reads)
        if (length(ReadCov[[Chrom]]@values) > 1){
          
          # Create genomic ranges for separate islands
          Islands <- slice(ReadCov, lower = 1)
          GRs <- GRanges(seqnames = Chrom, 
                  ranges = Islands@listData[[1]]@ranges,
                  coverTotal = viewSums(Islands)[[1]],
                  coverMax   = viewMaxs(Islands)[[1]],
                  coverMaxPos   = viewWhichMaxs(Islands)[[1]])
          blnOverlapIslands_All <- overlapsAny(GRs, L1GRanges)
          GRs <- GRs[!blnOverlapIslands_All]
          
        } else {
          GRanges()
        }
      })
      GRList <- GRangesList(GRList)
      GRList <- unlist(GRList)
      # IslGRanges_reduced <- reduce(GRList, min.gapwidth = MinGap,
      #                              with.revmap = T)
      # # Get maximum cover and position of maximum cover in reduced ranges
      # maxCoverOriginal    <- GRList@elementMetadata@listData$coverMax
      # maxCoverPosOriginal <- GRList@elementMetadata@listData$coverMaxPos
      # IslGRanges_reduced@elementMetadata@listData$coverMax <- sapply(IslGRanges_reduced@elementMetadata@listData$revmap, 
      #                    function(x) max(maxCoverOriginal[x]))
      # IslGRanges_reduced@elementMetadata@listData$coverMaxPos <- sapply(IslGRanges_reduced@elementMetadata@listData$revmap, 
      #                       function(x) maxCoverPosOriginal[x[which.max(maxCoverOriginal[x])]])
      # IslGRanges_reduced
      # blnOverlapIslands_All <- overlapsAny(IslGRanges_reduced, L1GRanges)
      # idxSuspectL1Ranges <- which(IslGRanges_reduced@elementMetadata@listData$coverMax > MinMaxCover & (!blnOverlapIslands_All))
      # IslGRanges_reduced[idxSuspectL1Ranges]
    })
   browser()
   IslGRanges <- GRangesList(GRangesNonRef)
   IslGRanges <- unlist(IslGRanges)
   cat(length(IslGRanges), "distinct peaks before merging peaks\n\n")

   #######################################
   #                                     #
   #    Reduce 'islands' with         #
   #        nonzero coverage             #
   #                                     #
   #######################################

   # Merge ranges that are less than MinGap bp apart
   IslGRanges_reduced <- reduce(IslandGRanges, min.gapwidth = MinGap,
                             with.revmap = T)
   cat(length(IslGRanges_reduced), "distinct peaks after merging peaks that")
   cat("are less than", MinGap, "apart\n\n")

   #######################################
   #                                     #
   #    Find 'islands' not overlapping   #
   #        with reference L1            #
   #                                     #
   #######################################
   
   cat("***** Finding 'islands' not overlapping with reference L1 ... *****\n")

   # Find overlaps between islands and L1HS ranges
   blnOverlapIslands_All <- overlapsAny(IslGRanges_reduced, L1GRanges)

   # Get maximum cover and position of maximum cover in reduced ranges
   maxCoverOriginal    <- IslandGRanges@elementMetadata@listData$coverMax
   maxCoverPosOriginal <- IslandGRanges@elementMetadata@listData$coverMaxPos
   maxCover <- sapply(IslGRanges_reduced@elementMetadata@listData$revmap, 
                   function(x) max(maxCoverOriginal[x]))
   maxCoverPos <- sapply(IslGRanges_reduced@elementMetadata@listData$revmap, 
                      function(x) maxCoverPosOriginal[x[which.max(maxCoverOriginal[x])]])
   
   # Get all ranges that make the maximum cover cut-off and don't overlap with
   # reference L1
   idxSuspectL1Ranges <- which(maxCover > MinMaxCover & (!blnOverlapIslands_All))
   SuspectL1Ranges    <- IslGRanges_reduced[idxSuspectL1Ranges]
   cat(length(idxSuspectL1Ranges), "peaks have maximum coverage of at least",
      MinMaxCover, "and do not overlap with reference L1\n")

   # Remove ranges of suspected L1s that are too close to reference L1
   DistToNearestL1    <- nearest(SuspectL1Ranges, L1GRanges)
   idxSuspectL1Ranges <- idxSuspectL1Ranges[DistToNearestL1 >= MinDist2L1]
   SuspectL1Ranges    <- IslGRanges_reduced[idxSuspectL1Ranges]
   maxCoverPos_SuspL1Ranges <- maxCoverPos[idxSuspectL1Ranges]
   cat(length(idxSuspectL1Ranges), "of the above peaks are at least", 
       MinDist2L1, "bp from nearest reference L1\n\n")
   
   #######################################
   #                                     #
   #    Find 'islands' overlapping       #
   #    with full-length reference L1    #
   #                                     #
   #######################################
   
   cat("***** Filtering reads overlapping with full-length reference L1 ... *****\n")

   # Find overlaps between islands and full-length L1HS ranges
   blnOverlapIslands_L1HS <- overlapsAny(IslGRanges_reduced, 
                                         L1HSFullLength_GRanges)
   
   # Get genomoc ranges of islands overlapping with full-length L1HS
   idxFullRefL1Ranges <- which(blnOverlapIslands_L1HS)
   FullRefL1Ranges    <- IslGRanges_reduced[blnOverlapIslands_L1HS]
   
   # Filter bam file to get reads in islands overlapping with full-length L1
   param <- ScanBamParam(which = FullRefL1Ranges, what = scanBamWhat())
   filterBam(file = BamFile, destination = OutBamFileFullLengthL1, param = param)
   
   #######################################################
   #                                                     #
   #    Save results                                     #
   #                                                     #
   #######################################################

   # Save results
   cat("*******  Saving results for ComparePeaksWithRefL1 to   *******\n")
   cat("*******", OutFile,  "*******\n")
   save(list = c("IslGRanges_reduced", "maxCover", "maxCoverPos", 
              "idxSuspectL1Ranges", "SuspectL1Ranges", 
              "FullRefL1Ranges", "idxFullRefL1Ranges"), 
     file = OutFile)

}


